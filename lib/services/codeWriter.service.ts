import fs from "fs";
import { FileProcedure } from "../models/procedure.model";
import { PROJECT_DIR } from "../constants/projectDir";
import { Adapter } from "../models/adapter.model";
import path from "path";
import { Stage } from "../models/stage.model";
import { stringifyObject } from "../utils/stringifyObject";

/**
 * Service to write code to a file
 */
export class CodeWriter {

  private readonly AUTO_GENERATED_FILE_HEADER = `// This file was generated by the Kottster App Builder\n// PLEASE AVOID EDITING THIS FILE MANUALLY\n\n`;

  /**
   * Write the adapter to the file
   * @description File src/adapters.js
   */
  public async writeAdapterToFile(adapter: Adapter): Promise<void> {
    const content = this.getAdaptersFileContent(adapter);
    const filePath = `${PROJECT_DIR}/src/adapters.js`;
    
    await this.writeFile(filePath, content);
    
    await this.generateAutoImports();
  }

  /**
   * Remove the component procedures file
   * @description File src/__generated__/dev/procedures/page_<pageId>_<componentType>_<componentId>.js
   */
  public async removeComponentProceduresFile(pageId: string, componentType: string, componentId: string): Promise<void> {
    // Check if the directory exists
    if (!fs.existsSync(`${PROJECT_DIR}/src/__generated__/dev/procedures`)) {
      return;
    }
    
    const filePath = `${PROJECT_DIR}/src/__generated__/dev/procedures/page_${pageId}_${componentType}_${componentId}.js`;
    
    await this.removeFile(filePath);
    await this.generateAutoImports();
  }

  /**
   * Remove all procedures for a page
   * @description Files inside src/__generated__/dev/procedures that start with `page_<pageId>`
   */
  public async removePageProceduresFromFile(pageId: string): Promise<void> {
    // Check if the directory exists
    if (!fs.existsSync(`${PROJECT_DIR}/src/__generated__/dev/procedures`)) {
      return;
    }

    // Get filenames that start with `page_<pageId>`
    const dirPath = `${PROJECT_DIR}/src/__generated__/dev/procedures`;
    const files = fs.readdirSync(dirPath);
    const filenames = files.filter(file => file.startsWith(`page_${pageId}`));
    
    // Remove all files
    filenames.forEach(async filename => {
      const filePath = path.join(dirPath, filename);
      await this.removeFile(filePath);
    });
  }

  /**
   * Write the component procedures to the file
   * @description File src/__generated__/dev/procedures/page_<pageId>_<componentType>_<componentId>.js
   */
  public async writeComponentProceduresToFile(pageId: string, componentType: string, componentId: string, procedures: FileProcedure[]): Promise<void> {
    const filePath = `${PROJECT_DIR}/src/__generated__/dev/procedures/page_${pageId}_${componentType}_${componentId}.js`;
    const content = this.getComponentProceduresFileContent(pageId, componentType, componentId, procedures);
    
    await this.writeFile(filePath, content);  
    await this.generateAutoImports();
  }

  /**
   * Copy dev files to prod ones file
   * @description Copy files from src/__generated__/dev/procedures/ to src/__generated__/prod/procedures/
   */
  public async copyDevFilesToProd(): Promise<void> {
    const devDir = path.join(PROJECT_DIR, 'src/__generated__/dev');
    const prodDir = path.join(PROJECT_DIR, 'src/__generated__/prod');

    // Check if src/__generated__/dev exists
    if (fs.existsSync(devDir)) {
      // Remove src/__generated__/prod directory
      if (fs.existsSync(prodDir)) {
        fs.rmdirSync(prodDir, { recursive: true });
      }

      // Copy src/__generated__/dev to src/__generated__/prod
      this.copyDirectory(
        devDir, 
        prodDir
      );

      // TODO: refactor this code
      // For all files inside src/__generated__/prod/procedures, 
      // replace 'const STAGE = 'dev';' with 'const STAGE = 'prod';'
      const files = fs.readdirSync(path.join(prodDir, 'procedures'));
      files.forEach(file => {
        const filePath = path.join(path.join(prodDir, 'procedures'), file);
        const content = fs.readFileSync(filePath, 'utf-8');
        const newContent = content.replace(`const STAGE = 'dev';`, `const STAGE = 'prod';`);
        fs.writeFileSync(filePath, newContent);
      });
    }

    await this.generateAutoImports();
  }

  /**
   * Generate the auto imports
   * @description File src/__generated__/index.js
   */
  public async generateAutoImports(): Promise<void> {
    let content = this.AUTO_GENERATED_FILE_HEADER;

    // Get filenames in a directory
    function getFilenames(dir: string): string[] {
      const filenames: string[] = [];

      // If directory doesn't exist, return empty array
      if (!fs.existsSync(dir)) {
        return filenames;
      }
      
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        filenames.push(file);
      });

      return filenames;
    }

    // Get all files inside ../src/__generated__/procedures/<stage>
    let files: string[] = [];
    Object.values(Stage).forEach(stage => {
      files = files.concat(getFilenames(path.join(PROJECT_DIR, `src/__generated__/${stage}/procedures`)));
    });

    // Generate imports
    const imports: string[] = [];
    files.forEach(file => {
      imports.push(`import './${file}';`);
    });

    content += imports.join('\n') + '\n';

    // Write the file
    await this.writeFile(path.join(PROJECT_DIR, 'src/__generated__/', 'index.js'), content);
  }

  private async writeFile(filePath: string, content: string): Promise<void> {
    // Create directory if it doesn't exist
    const fileDirPath = filePath.replace(/\/[^/]+$/, '');
    if (!fs.existsSync(fileDirPath)) {
      fs.mkdirSync(fileDirPath, { recursive: true });
    }

    fs.writeFileSync(filePath, content);
  }

  private async removeFile(filePath: string): Promise<void> {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    };

    await this.generateAutoImports();
  }

  private copyDirectory(src: string, dest: string): void {
    // Create the destination directory if it doesn't exist
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }
  
    // Read the source directory
    const files = fs.readdirSync(src);
  
    // Iterate over each file/directory in the source directory
    files.forEach((file) => {
      const srcPath = path.join(src, file);
      const destPath = path.join(dest, file);
  
      // Recursively copy subdirectories
      if (fs.lstatSync(srcPath).isDirectory()) {
        this.copyDirectory(srcPath, destPath);
      } else {
        // Copy files
        fs.copyFileSync(srcPath, destPath);
      }
    });
  }

  private getComponentProceduresFileContent(pageId: string, componentType: string, componentId: string, procedures: FileProcedure[]): string {
    let content: string = this.AUTO_GENERATED_FILE_HEADER;
    
    // Add the imports
    content += `import { app } from '../../../app';\n\n`;

    content += `const STAGE = '${Stage.development}';\n`;
    content += `const PAGE_ID = '${pageId}';\n`;
    content += `const COMPONENT_TYPE = '${componentType}';\n`;
    content += `const COMPONENT_ID = '${componentId}';\n\n`;

    // For each component, add the procedures
    content += `app.registerProceduresForComponent(STAGE, PAGE_ID, COMPONENT_TYPE, COMPONENT_ID, {\n`;
    procedures.forEach(procedure => {
      const { functionBody, procedureName } = procedure;
      content += `  '${procedureName}': ${functionBody},\n`;
    });
    content += `});\n\n`;

    return content;
  }

  private getAdaptersFileContent(adapter: Adapter): string {
    let content: string = '';

    // Add the imports
    content += `import { createAdapter } from '@kottster/backend';\n\n`;

    // Add adapters initialization
    content += `const adapters = [\n`;
    content += `  createAdapter(\n    '${adapter.type}', \n    ${stringifyObject({ connectionOptions: adapter.getConnectionOptions() }, '    ')}\n  )\n`;
    content += `];\n\n`;

    // Export the adapters
    content += `export default adapters;\n\n`;
    
    return content;
  }
}
