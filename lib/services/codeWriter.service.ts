import fs from "fs";
import { FileProcedure } from "../models/procedure.model";
import { PROJECT_DIR } from "../constants/projectDir";
import { Adapter } from "../models/adapter.model";
import path from "path";
import { Stage } from "../models/stage.model";
import { stringifyObject } from "../utils/stringifyObject";
import { parseModule } from "esprima";

/**
 * Service to write code to a file
 */
export class CodeWriter {

  private readonly AUTO_GENERATED_FILE_HEADER = `// This file was generated by the Kottster App Builder\n// PLEASE AVOID EDITING THIS FILE MANUALLY\n\n`;

  /**
   * Write the adapter to the file
   * @description File src/adapters.js
   */
  public async writeAdapterToFile(adapter: Adapter): Promise<void> {
    const content = this.getAdaptersFileContent(adapter);
    const filePath = `${PROJECT_DIR}/src/adapters.js`;
    
    this.writeFile(filePath, content);
    
    this.generateAutoImports();
  }

  /**
   * Write the procedures to the file
   * @description File src/__generated__/<stage>/procedures.js & src/__generated__/<stage>/procedures.json
   */
  public async writeProceduresToFile(stage: Stage, procedures: FileProcedure[]): Promise<void> {
    const filePath = `${PROJECT_DIR}/src/__generated__/${stage}/procedures.js`;
    const content = this.getProceduresFileContent(procedures);
    
    // Check if the content is valid
    if (!this.isJSCodeValid(content)) {
      throw new Error('Invalid JavaScript code');
    }
    
    this.writeFile(filePath, content);
    this.generateAutoImports();

    // Add procedures.json file nearby
    const jsonFilePath = filePath.replace(/\.js$/, '.json');
    const jsonContent = JSON.stringify(procedures, null, 2);
    this.writeFile(jsonFilePath, jsonContent);
  }

  /**
   * Copy dev files to prod ones file
   * @description Copy procedures.js from src/__generated__/dev to src/__generated__/prod
   */
  public async copyDevFilesToProd(): Promise<void> {
    // Get dev procedures
    const filePath = `${PROJECT_DIR}/src/__generated__/${Stage.development}/procedures.json`;
    const devJsonFileContent = this.readFile(filePath);
    const devProcedures = JSON.parse(devJsonFileContent) as FileProcedure[];
    
    // Create prod procedures by changing the stage to 'prod'
    const prodProcedures = devProcedures.map(procedure => {
      return {
        ...procedure,
        stage: Stage.production
      };
    });

    // Write prod procedures
    this.writeProceduresToFile(Stage.production, prodProcedures);
  }

  /**
   * Generate the auto imports
   * @description File src/__generated__/index.js
   */
  public generateAutoImports(): void {
    let content = this.AUTO_GENERATED_FILE_HEADER;

    // Get filenames in a directory
    function getFilenames(dir: string): string[] {
      const filenames: string[] = [];

      // If directory doesn't exist, return empty array
      if (!fs.existsSync(dir)) {
        return [];
      }
      
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        filenames.push(file);
      });

      return filenames;
    }

    // Get all files inside ../src/__generated__/<stage>
    const files: string[] = [];
    Object.values(Stage).forEach(stage => {
      const filenames = getFilenames(path.join(PROJECT_DIR, `src/__generated__/${stage}`));
      filenames.forEach(filename => {
        if (filename.endsWith('.js')) {
          files.push(`${stage}/${filename}`);
        }
      });
    });

    // Generate imports
    const imports: string[] = [];
    files.forEach(file => {
      imports.push(`import './${file}';`);
    });

    content += imports.join('\n') + '\n';

    // Write the file
    this.writeFile(path.join(PROJECT_DIR, 'src/__generated__/', 'index.js'), content);
  }

  private writeFile(filePath: string, content: string): void {
    // Create directory if it doesn't exist
    const fileDirPath = filePath.replace(/\/[^/]+$/, '');
    if (!fs.existsSync(fileDirPath)) {
      fs.mkdirSync(fileDirPath, { recursive: true });
    }

    fs.writeFileSync(filePath, content);
  }

  private readFile(filePath: string): string {
    return fs.readFileSync(filePath, 'utf8');
  }

  private removeFile(filePath: string): void {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    };

    this.generateAutoImports();
  }

  private copyDirectory(src: string, dest: string): void {
    // Create the destination directory if it doesn't exist
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }
  
    // Read the source directory
    const files = fs.readdirSync(src);
  
    // Iterate over each file/directory in the source directory
    files.forEach((file) => {
      const srcPath = path.join(src, file);
      const destPath = path.join(dest, file);
  
      // Recursively copy subdirectories
      if (fs.lstatSync(srcPath).isDirectory()) {
        this.copyDirectory(srcPath, destPath);
      } else {
        // Copy files
        fs.copyFileSync(srcPath, destPath);
      }
    });
  }

  private getProceduresFileContent(procedures: FileProcedure[]): string {
    let content: string = this.AUTO_GENERATED_FILE_HEADER;
    
    // Add the imports
    content += `import { app } from '../../app';\n\n`;

    // Register the procedures
    procedures.forEach(procedure => {
      const { stage, pageId, componentType, componentId, functionBody, procedureName } = procedure;
      content += `app.registerProcedureForComponent('${stage}', '${pageId}', '${componentType}', '${componentId}', '${procedureName}', ${functionBody});\n\n`;
    });

    return content;
  }

  private getAdaptersFileContent(adapter: Adapter): string {
    let content: string = '';

    // Add the imports
    content += `import { createAdapter } from '@kottster/backend';\n\n`;

    // Add adapters initialization
    content += `const adapters = [\n`;
    content += `  createAdapter(\n    '${adapter.type}', \n    ${stringifyObject({ connectionOptions: adapter.getConnectionOptions() }, '    ')}\n  )\n`;
    content += `];\n\n`;

    // Export the adapters
    content += `export default adapters;\n\n`;
    
    return content;
  }

  private isJSCodeValid(code: string): boolean {
    try {
      parseModule(code, { tolerant: true });
      return true;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
}
